Chào bạn,

Dựa trên các tệp mã nguồn bạn đã cung cấp và mô tả vấn đề, ứng dụng web của bạn đang gặp hai vấn đề chính:

### 1. Lỗi "404 Not Found" khi làm mới trang (Reload)

Vấn đề "404 Not Found" khi bạn làm mới trang (reload) hoặc truy cập trực tiếp vào một đường dẫn như `https://devpros-achievo.replit.app/organization-dashboard` là một vấn đề phổ biến với các ứng dụng một trang (Single Page Applications - SPAs) sử dụng chế độ lịch sử của Vue Router (`createWebHistory`).

**Giải thích nguyên nhân:**
Khi bạn sử dụng `createWebHistory()`, Vue Router thay đổi URL trình duyệt mà không cần tải lại trang. Tuy nhiên, khi bạn làm mới trang hoặc truy cập trực tiếp một đường dẫn (ví dụ: `/organization-dashboard`), trình duyệt sẽ gửi yêu cầu đến máy chủ với đường dẫn đó. Nếu máy chủ không có tệp tĩnh tương ứng với đường dẫn đó (mà chỉ có tệp `index.html` duy nhất), máy chủ sẽ trả về lỗi "404 Not Found". Vue Router cần tệp `index.html` được trả về để nó có thể khởi tạo lại ứng dụng và xử lý định tuyến phía máy khách.

**Cách khắc phục:**
Để khắc phục lỗi này, bạn cần cấu hình máy chủ web (trong trường hợp này là môi trường triển khai của Replit) để tất cả các yêu cầu không khớp với tệp tĩnh nào đều được chuyển hướng (fallback) về tệp `index.html` của ứng dụng.

Replit hỗ trợ nhiều cách triển khai. Đối với các ứng dụng tĩnh hoặc ứng dụng Node.js đơn giản, bạn có thể cần cấu hình một tệp máy chủ nhỏ (ví dụ: Express.js) để phục vụ các tệp đã build của Vite và xử lý fallback.

Một cách phổ biến để làm điều này là sử dụng một máy chủ HTTP đơn giản như `serve-static` hoặc một framework như `Express.js` để phục vụ các tệp tĩnh từ thư mục `dist` (sau khi bạn chạy `npm run build`) và thêm một fallback cho mọi đường dẫn không xác định.

**Ví dụ cấu hình máy chủ Node.js (nếu bạn có thể chạy một server Node.js trên Replit):**

1.  **Đảm bảo đã cài đặt `express` và `serve-static`:**
    ```bash
    npm install express serve-static
    ```
2.  **Tạo một tệp server (ví dụ: `server.js`) trong thư mục gốc của dự án:**
    ```javascript
    import express from 'express'
    import path from 'path'
    import { fileURLToPath } from 'url'

    // Get __dirname equivalent in ES Modules
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)

    const app = express()
    const port = process.env.PORT || 3000 // Replit sets PORT env variable

    // Serve static files from the 'dist' directory (Vite's build output)
    app.use(express.static(path.join(__dirname, 'dist')))

    // Fallback to index.html for all other routes (Vue Router history mode)
    app.get('*', (req, res) => {
      res.sendFile(path.join(__dirname, 'dist', 'index.html'))
    })

    app.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`)
    })
    ```
3.  **Cập nhật `package.json` để chạy server này sau khi build:**
    Thay đổi script `start` hoặc thêm một script mới:
    ```json
    {
      "name": "vuejs-with-vite",
      "version": "0.0.0",
      "scripts": {
        "dev": "vite",
        "build": "vite build",
        "preview": "vite preview --port 4173",
        "start": "node server.js" // Add this line
      },
      // ...
    }
    ```
    Sau khi bạn chạy `npm run build`, Replit sẽ chạy `npm start` (hoặc script bạn cấu hình) để khởi động máy chủ Node.js phục vụ ứng dụng của bạn.

### 2. Vấn đề tạo khóa học: Form không biến mất, khóa học biến mất sau khi tải lại

Các hành vi này cho thấy sự không nhất quán trong quản lý trạng thái giao diện người dùng và cách dữ liệu được truy xuất từ Firebase.

**Phân tích mã nguồn:**

* **`src/services/api.js` (`getCourses`)**: Hàm `getCourses` có một khối `try-catch` bao bọc việc gọi `firebaseService.getCourses()`. Trong trường hợp `firebaseService.getCourses()` gặp lỗi (hoặc mất quá nhiều thời gian), nó sẽ **fallback** để trả về `mockData.courses`.
    ```javascript
    // src/services/api.js
    api.getCourses = async () => {
      try {
        console.log('API: Getting courses from Firebase...')
        const courses = await firebaseService.getCourses()
        console.log('API: Courses retrieved:', courses)
        return { data: courses || [] }
      } catch (error) {
        console.error('Failed to get courses:', error)
        // Fallback to mock data if Firebase fails
        console.log('API: Falling back to mock data')
        return createMockApiCall(mockData.courses) // Đây là nguyên nhân tiềm ẩn
      }
    }
    ```
    Đây là nguyên nhân rất có thể cho việc "khóa học biến mất khỏi giao diện" sau khi tải lại. Nếu Firebase phản hồi chậm hoặc không thành công trong lần tải đầu tiên (sau khi bạn thấy khóa học xuất hiện tạm thời), ứng dụng sẽ hiển thị dữ liệu giả định (`mockData`) không chứa khóa học mới của bạn.

* **Logic cập nhật giao diện sau khi tạo khóa học:**
    Việc "giao diện điền form thông tin để tạo khóa học sau đó vẫn không biến mất" cho thấy thành phần giao diện người dùng (component Vue) chịu trách nhiệm tạo khóa học chưa xử lý đúng phản hồi thành công từ API.

**Cách khắc phục:**

1.  **Loại bỏ hoặc quản lý cẩn thận `mockData` fallback:**
    * **Để Debug:** Tạm thời, hãy thử **comment out** dòng `return createMockApiCall(mockData.courses)` trong `src/services/api.js`'s `getCourses` để buộc ứng dụng luôn lấy dữ liệu từ Firebase. Nếu Firebase thực sự có vấn đề về kết nối hoặc quy tắc bảo mật, bạn sẽ thấy lỗi rõ ràng hơn trong console.
    * **Giải pháp lâu dài:**
        * Đảm bảo cấu hình Firebase trong `src/services/firebase.js` là chính xác.
        * Kiểm tra quy tắc bảo mật (Firestore Security Rules) trong dự án Firebase của bạn để đảm bảo người dùng có quyền ghi và đọc vào bộ sưu tập `courses`.
        * Thay vì fallback im lặng về mock data, hãy hiển thị thông báo lỗi rõ ràng cho người dùng nếu Firebase không thể trả về dữ liệu.
        * Sau khi tạo khóa học thành công, bạn cần đảm bảo rằng danh sách khóa học trong ứng dụng được cập nhật bằng cách gọi lại `api.getCourses()` hoặc cập nhật trạng thái Pinia store chứa danh sách khóa học.

2.  **Cải thiện quy trình tạo khóa học trong giao diện người dùng (Component Vue):**
    Mặc dù tôi không có quyền truy cập vào các tệp component Vue của bạn (ví dụ: `OrganizationDashboard.vue` nếu đó là nơi bạn tạo khóa học), logic chung sẽ như sau:

    ```javascript
    // Ví dụ giả định trong một component Vue (e.g., OrganizationDashboard.vue)
    import { api } from '../services/api'
    // import { useCourseStore } from '../stores/course' // Nếu bạn có một store riêng cho Course

    export default {
      data() {
        return {
          courseForm: { /* ... fields ... */ },
          isSubmitting: false,
          courses: [] // Hoặc lấy từ Pinia store
        }
      },
      async created() {
        await this.fetchCourses()
      },
      methods: {
        async fetchCourses() {
          try {
            const response = await api.getCourses()
            this.courses = response.data // Cập nhật danh sách khóa học
          } catch (error) {
            console.error('Error fetching courses:', error)
            // Xử lý lỗi, hiển thị thông báo cho người dùng
          }
        },
        async createNewCourse() {
          this.isSubmitting = true
          try {
            const response = await api.createCourse(this.courseForm)
            console.log('Course created successfully:', response.data)
            // Sau khi tạo thành công:
            this.courseForm = { /* reset form fields to initial empty state */ } // Xóa form
            await this.fetchCourses() // Tải lại danh sách khóa học để hiển thị khóa học mới
            // Hoặc: this.courses.push(response.data) nếu bạn muốn cập nhật cục bộ nhanh chóng
            // Nhưng luôn cần một cơ chế để đồng bộ với Firebase sau đó.
            // Hiển thị thông báo thành công cho người dùng
          } catch (error) {
            console.error('Failed to create course:', error)
            // Xử lý lỗi, hiển thị thông báo lỗi cho người dùng
          } finally {
            this.isSubmitting = false
          }
        }
      }
    }
    ```
    Hãy chắc chắn rằng sau khi gọi `api.createCourse` thành công, bạn thực hiện các bước sau:
    * **Reset form:** Đặt lại các trường nhập liệu của form về trạng thái ban đầu (trống).
    * **Tải lại danh sách khóa học:** Gọi lại hàm `fetchCourses()` (hoặc tương đương) để tải lại dữ liệu từ Firebase. Điều này đảm bảo danh sách hiển thị là chính xác và bao gồm khóa học mới.

Bằng cách áp dụng các giải pháp này, bạn sẽ cải thiện đáng kể sự ổn định và độ chính xác của ứng dụng.

Nếu bạn cần thêm trợ giúp về bất kỳ phần nào của các giải pháp này, đừng ngần ngại hỏi nhé!